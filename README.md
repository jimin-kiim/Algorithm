# Algorithm
  When we face a problem, we should get the solution algorithm; a step by step procedure. And we should prove that the solution algorithm we found is the best algorithm with mathematical, systematic or logical proof. 

  Key steps for this is modeling the problem, designing and analyzing the algorithm. There already exist classical[fundamental] algorithms and classic problems that are classified according to their difficulty. Handling new problems we ecounter, we can make use of the sets of classic problems and their solution algorithms. 


- BF
- [Divide and Conquer][Divide and Conquer]
- [Dynamic Programming][Dynamic Programming]
- [Greedy][Greedy]
- [Backtracking][Backtracking]
- [Branch and Bound][Branch and Bound]
- [NP Theory and Approximation][NP Theory and Approximation]

[NP Theory and Approximation]: https://github.com/jimin-kiim/Algorithm/issues/15#issue-1725031637
[Branch and Bound]: https://github.com/jimin-kiim/Algorithm/issues/11#issue-1709282885
[Backtracking]: https://github.com/jimin-kiim/Algorithm/issues/10#issue-1709282767
[Greedy]: https://github.com/jimin-kiim/Algorithm/issues/6#issue-1687978543
[Dynamic Programming]: https://github.com/jimin-kiim/Algorithm/issues/5#issue-1687978029
[Divide and Conquer]: https://github.com/jimin-kiim/Algorithm/issues/4#issue-1687977759